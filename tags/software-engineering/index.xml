<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Engineering on Bhaskar Karambelkar&#39;s Blog</title>
    <link>/tags/software-engineering/index.xml</link>
    <description>Recent content in Software Engineering on Bhaskar Karambelkar&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Â© 2007-2017 Bhaskar V. Karambelkar. All rights reserved.</copyright>
    <atom:link href="/tags/software-engineering/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Data Scientists And Software Engineering</title>
      <link>/2017/04/data-scientists-and-software-engineering/</link>
      <pubDate>Thu, 13 Apr 2017 22:29:01 -0400</pubDate>
      
      <guid>/2017/04/data-scientists-and-software-engineering/</guid>
      <description>

&lt;h1 id=&#34;coding-software-engineering&#34;&gt;Coding != Software Engineering&lt;/h1&gt;

&lt;p&gt;As has been mentioned ad nauseam: Any one can code. What has not been said enough is that there is a lot more to coding than merely assembling a set of instructions in a programming language of your choice to make the machine do what you want. Not as catchy as &amp;lsquo;Any one can code!&amp;rsquo;, is it?&lt;/p&gt;

&lt;p&gt;As a professional software developer turned data scientist, I feel compelled to share some software engineering wisdom with my fellow data scientist who may have followed a non coding heavy path. If you are an academic researcher turned data scientist, or perhaps a data analyst used to point-and-click GUI tools, or excel (the horror!), then learning and being able to code in a programming language can be a liberating, exhilarating, but also a very scary experience. But fear not, this post is just for you, and hopefully some of my points will encourage you to explore software engineering in more detail.&lt;/p&gt;

&lt;h1 id=&#34;so-what-is-software-engineering&#34;&gt;So What is Software Engineering?&lt;/h1&gt;

&lt;p&gt;Instead of referencing a formal definition which you can easily look up using Google, let me tell you what I think the practice of software engineering aims to accomplish. Writing more or less working code is the easy part. What software engineering aims to accomplish is making the code portable, concise, relatively bug free, secure, performant within given constraints, and reusable, all with limited man-power and budget. And believe me, this is not as easy as you might think it is, nor is this process a natural extension of the practice of coding. By that I mean that you can&amp;rsquo;t learn software engineering by coding more and more, let alone master it. Proper software engineering is an art+science on to it self, of which coding skills are an important but nonetheless only a small piece.&lt;/p&gt;

&lt;p&gt;The reason I chose to explain software engineering this way, is because, the term software engineering is in itself somewhat controversial and debated. So instead of drowning you in the controversy about the term, I present my understanding of the intent behind software engineering. But be forewarned that this is one person&amp;rsquo;s opinion so take it for what it&amp;rsquo;s worth.&lt;/p&gt;

&lt;h1 id=&#34;so-why-must-data-scientists-care&#34;&gt;So Why Must Data Scientists Care?&lt;/h1&gt;

&lt;p&gt;For many a reasons. As I mentioned previously more and more data analysis is now done in code rather than point-and-click GUI tools. This places the added burden of learning how to code on an data analyst / researcher who may not have had exposure to coding before. Even if you had taken a programming language class before, it was mostly to teach you the syntax of the programming language rather than teach you about software engineering.&lt;/p&gt;

&lt;p&gt;The implications of the above are they you may write code that works but it may have all sorts of issues. It may not be portable on account of using non-portable APIs/Libraries. It may not be optimized/concise and as a result non performant at scale. It may have a large surface area for bugs and security vulnerabilities. It may not be maintainable in the long run, and hence prevent you from reproducing your results in the future.&lt;/p&gt;

&lt;p&gt;I would go as far as to argue that if you care about the veracity and reproducibility of your research/analysis then you absolutely must care about software engineering.&lt;/p&gt;

&lt;h1 id=&#34;cliff-notes-for-software-engineering&#34;&gt;Cliff Notes for Software Engineering&lt;/h1&gt;

&lt;p&gt;I must warn you this page is only meant to get you started on software engineering, and not tell you all that there is about it. Even then, following most of my advice below will make you a better coder (ahem software engineer).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Have a basic understanding of how computer systems work. The hardware, the software (including OS/Kernel), the network, the Internet. &lt;strong&gt;This will go a long way, I promise&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Try and pick up at least 2 or 3 programming languages. Broaden your repertoire.&lt;/li&gt;
&lt;li&gt;Learn about various programming paradigms like imperative, object-oriented, functional etc.&lt;/li&gt;
&lt;li&gt;Many a modern languages don&amp;rsquo;t strictly fall under a single paradigm. Form a habit of recognizing which features adhere to which paradigms.&lt;/li&gt;
&lt;li&gt;Embrace each programing language&amp;rsquo;s idiosyncrasies rather that fight them. If in doubt always remember that people lot smarter than you put hours into developing the language/API/library you are using.&lt;/li&gt;
&lt;li&gt;Have a good understanding of the &lt;strong&gt;standard library&lt;/strong&gt; of a programming language. It will prevent you from inefficiently duplicating functionality that was at your disposal from the get go.&lt;/li&gt;
&lt;li&gt;In addition to the standard library research a bit on some leading 3rd party libraries/APIs available. Someone always has the problem solved before you. Your skill lies in finding it rather than duplicating it.&lt;/li&gt;
&lt;li&gt;Start picking up on how to distinguish efficient vs inefficient code. Efficiency can defined in terms of performance, conciseness, resource consumption etc.&lt;/li&gt;
&lt;li&gt;Teach yourself the principles of &lt;strong&gt;application security&lt;/strong&gt; and secure coding. Not being a full time software developer doesn&amp;rsquo;t alleviate you from writing secure code.&lt;/li&gt;
&lt;li&gt;Think beyond your immediate use case. Think of use cases in future or use cases by users other than yourself. &amp;ldquo;It suffices my needs&amp;rdquo; is a narrow mindset.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write less code and more comments&lt;/strong&gt;. Think of that someone who has to read your code six months or an year from now. Even if that someone is you, I can tell you from experience that reading properly commented code can do wonders to lower your stress levels.&lt;/li&gt;
&lt;li&gt;Be critical of your coding abilities rather than being confident about them. Let that imposter syndrome be your motivation to improve.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Automate your testing&lt;/strong&gt;. Be it unit tests or integration tests, take out the human as much as possible from the equation.&lt;/li&gt;
&lt;li&gt;Learn about &lt;strong&gt;software delivery pipelines&lt;/strong&gt;. Continuous integration (CI), automated deployments, devops are not just buzzwords. They play a critical part in your overall product development.&lt;/li&gt;
&lt;li&gt;Familiarize yourself with distributed computing, cloud environments, virtualization and container technologies.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The last four ones are special and deserve to be separated out from the rest.
Always follow them no matter how big/small your program/script is, and how much you are pressed for time. Excuse the shouting because they are that much important.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NEVER CODE WITHOUT A VERSION CONTROL SYSTEM, PREFERABLY GIT&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DON&amp;rsquo;T HARD CODE STRINGS, NUMBERS, FILE/DIRECTORY NAMES EVER!&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ALWAYS METICULOUSLY DOCUMENT YOUR &amp;ldquo;CLEVER&amp;rdquo; HACKS. ALWAYS!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DON&amp;rsquo;T BLINDLY COPY CODE FROM STACK OVERFLOW&lt;/strong&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>